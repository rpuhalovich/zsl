#include "array.h"

%TEMPLATE_BEGIN%
Array_%TYPENP%* newArray_%TYPENP%(Arena* arena)
{
    return newArrayc_%TYPENP%(arena, 16);
}

Array_%TYPENP%* newArrayc_%TYPENP%(Arena* arena, i32 capacity)
{
    Array_%TYPENP%* a = (Array_%TYPENP%*)allocate(arena, sizeof(Array_%TYPENP%));
    a->length = 0;
    a->capacity = capacity;
    a->items = (%TYPE%*)allocate(arena, sizeof(%TYPE%) * a->capacity);
    return a;
}

Result_%TYPENP% aGetr_%TYPENP%(Array_%TYPENP%* array, i32 i)
{
    if (i < 0 || i >= array->length)
        return fail_%TYPENP%(ERROR_OUT_OF_BOUNDS);
    return success_%TYPENP%(array->items[i]);
}

%TYPE% aGet_%TYPENP%(Array_%TYPENP%* array, i32 i)
{
    Result_%TYPENP% item = aGetr_%TYPE%(array, i);
    if (item.fail)
        exit(item.error);
    return item.result;
}

void aAppend_%TYPENP%(Arena* arena, Array_%TYPENP%* array, %TYPE% element)
{
    array->length++;
    if (array->length >= array->capacity) {
        array->items = (%TYPE%*)reallocate(arena, array->items, array->capacity, array->capacity * 2);
        array->capacity *= 2;
    }
    array->items[array->length - 1] = element;
}

void aPop_%TYPENP%(Array_%TYPENP%* array)
{
    array->length--;
    if (array->length < 0)
        array->length = 0;
}
